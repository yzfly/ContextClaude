# Unified Development Workflow - Create Command

<task>
You are the unified entry point for all development projects. You intelligently analyze task complexity and route to appropriate workflow commands to complete coding projects efficiently.
</task>

<context>
Input: "$ARGUMENTS"

This is the master command that:
1. Analyzes task requirements and complexity
2. Processes input (either direct command or reads TASK_PROMPT.md)
3. Routes to appropriate workflow: builder, designer + builder, or learner + designer + builder
4. Manages project context and directory structure
</context>

<input_processing>
## Step 1: Input Analysis

### Input Method Detection
Check if arguments provided: "$ARGUMENTS"

**If arguments provided** (Direct Command Mode):
- Extract task description from arguments
- Enhance and polish the requirement description
- Create/update `TASK_PROMPT.md` with enhanced requirements
- Continue to complexity analysis

**If no arguments** (Document Mode):
- Check if `TASK_PROMPT.md` exists and has content
- If exists: Read requirements from document
- If missing: Ask user to either provide arguments or create TASK_PROMPT.md
- Continue to complexity analysis

### Requirement Enhancement (Direct Command Mode)
When processing direct input, enhance the user's description by:
- Clarifying ambiguous requirements
- Adding missing technical considerations
- Structuring the requirements logically
- Identifying key deliverables and success criteria
- Suggesting best practices and patterns

Save enhanced requirements to `TASK_PROMPT.md` in this format:
```markdown
# Project Requirements

## Original Request
[User's original description]

## Enhanced Requirements
[Polished and detailed requirements]

## Key Deliverables
- [Specific deliverable 1]
- [Specific deliverable 2]

## Technical Considerations
- [Technical requirement 1]
- [Technical requirement 2]

## Success Criteria
- [Measurable outcome 1]
- [Measurable outcome 2]
```
</input_processing>

<complexity_analysis>
## Step 2: Task Complexity Assessment

Analyze the requirements to determine workflow path:

### Simple Tasks ‚Üí `builder` only
**Criteria:**
- Requirements are clear and specific
- No external APIs or complex integrations needed
- Standard patterns and well-known technologies
- Minimal architecture decisions required
- Sufficient context already available

**Examples:**
- "Create a simple todo list app"
- "Build a basic calculator component"
- "Implement user authentication form"

### Medium Tasks ‚Üí `designer` ‚Üí `builder`
**Criteria:**
- Requirements need architectural planning
- Multiple components or modules involved
- Some design decisions and trade-offs to consider
- Integration between different parts needed
- Technical approach needs to be planned

**Examples:**
- "Build an e-commerce shopping cart system"
- "Create a blog platform with admin panel"
- "Develop a data visualization dashboard"

### Complex Tasks ‚Üí `learner` ‚Üí `designer` ‚Üí `builder`
**Criteria:**
- Requires external knowledge or API learning
- User provided extensive documentation/examples
- Novel integration patterns or unfamiliar technologies
- Multiple external systems or services involved
- Significant research phase needed

**Examples:**
- "Build WeChat mini-program with payment integration" (with API docs provided)
- "Create blockchain application" (with extensive technical documentation)
- "Integrate with complex enterprise API" (with specification documents)

## Complexity Decision Logic
```
Check context directory:
- If .context/data/ has extensive documentation ‚Üí Complex
- If .context/examples/ has reference implementations ‚Üí Complex
- If external APIs/services mentioned + docs provided ‚Üí Complex

Check requirements scope:
- If multiple systems/integrations ‚Üí Medium minimum
- If single-purpose with clear patterns ‚Üí Simple
- If architectural decisions needed ‚Üí Medium minimum

Check technology familiarity:
- If standard web/mobile technologies ‚Üí Simple/Medium
- If specialized domains (blockchain, AI, IoT) ‚Üí Complex
- If extensive external dependencies ‚Üí Complex
```
</complexity_analysis>

<directory_management>
## Step 3: Directory Structure Setup

Ensure proper directory structure exists:

```
./
‚îú‚îÄ‚îÄ .context/
‚îÇ   ‚îú‚îÄ‚îÄ TASK_PROMPT.md       # Main requirements (create if doesn't exist)
‚îÇ   ‚îú‚îÄ‚îÄ data/                # User-provided documentation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ web_docs.md     # API documentation summary
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [other-docs]     # Specifications, manuals
‚îÇ   ‚îú‚îÄ‚îÄ examples/            # Reference code and templates
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [code-files]     # Sample implementations
‚îÇ   ‚îú‚îÄ‚îÄ knowledge/           # Generated by learner command
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [knowledge-docs] # Processed learning materials
‚îÇ   ‚îî‚îÄ‚îÄ PRC.md              # Generated by designer command
‚îî‚îÄ‚îÄ .claude/
    ‚îú‚îÄ‚îÄ commands/           # Workflow commands
    ‚îî‚îÄ‚îÄ claude-code/       # Documentation and settings
```

### Directory Creation
1. Create `.context/` if it doesn't exist
2. Create subdirectories: `data/`, `examples/`, `knowledge/`
3. Check if user has provided materials in `data/` and `examples/`
4. Report on available context materials
</directory_management>

<workflow_execution>
## Step 4: Execute Appropriate Workflow

Based on complexity analysis, execute the determined workflow:

### Simple Task Workflow
```bash
Execute: /user:build "$ARGUMENTS"
```
- Direct implementation without additional planning
- Uses existing context and TASK_PROMPT.md
- Suitable for straightforward development tasks

### Medium Task Workflow
```bash
1. Execute: /user:design "$ARGUMENTS"
   ‚Üí Generates: .context/PRC.md (Project Requirements & Architecture)
   
2. Execute: /user:build "$ARGUMENTS"  
   ‚Üí Uses: TASK_PROMPT.md + PRC.md for implementation
```
- First phase: Requirements analysis and architecture design
- Second phase: Implementation based on detailed planning

### Complex Task Workflow
```bash
1. Execute: /user:learn "$ARGUMENTS"
   ‚Üí Processes: .context/data/ and .context/examples/
   ‚Üí Generates: .context/knowledge/ (organized learning materials)
   
2. Execute: /user:design "$ARGUMENTS"
   ‚Üí Uses: TASK_PROMPT.md + knowledge/ 
   ‚Üí Generates: .context/PRC.md
   
3. Execute: /user:build "$ARGUMENTS"
   ‚Üí Uses: All context materials for implementation
```
- First phase: Knowledge extraction and learning
- Second phase: Architecture and requirements analysis  
- Third phase: Complete implementation

## Workflow Communication
For each step, clearly communicate:
- Which workflow path was selected and why
- What each command will accomplish
- What outputs will be generated
- How context materials are being utilized
</workflow_execution>

<context_utilization>
## Context Material Integration

### Input Materials Processing
**User Documentation** (`.context/data/`):
- API specifications and documentation
- Business requirements documents
- Technical standards and guidelines
- Integration specifications

**Reference Code** (`.context/examples/`):
- Template implementations
- Reference architectures  
- Code samples and patterns
- Previous similar projects

### Generated Outputs
**Knowledge Base** (`.context/knowledge/`) - Created by `learner`:
- Processed API documentation
- Extracted key patterns and practices
- Integration guidelines and examples
- Technical decision rationales

**Project Requirements** (`.context/PRC.md`) - Created by `designer`:
- Detailed requirements analysis
- Architecture and design decisions
- Implementation plan and milestones
- Technical specifications and interfaces

### Context Flow
```
User Input ‚Üí Enhanced Requirements (TASK_PROMPT.md)
    ‚Üì
External Docs ‚Üí Processed Knowledge (.context/knowledge/)
    ‚Üì  
Analysis ‚Üí Project Requirements (.context/PRC.md)
    ‚Üì
Implementation ‚Üí Complete Project Code
```
</context_utilization>

<decision_tracking>
## Workflow Decision Documentation

After complexity analysis, document the decision:

```markdown
## Workflow Decision

**Task Complexity**: [Simple/Medium/Complex]

**Reasoning**:
- [Factor 1 that influenced decision]
- [Factor 2 that influenced decision] 
- [Factor 3 that influenced decision]

**Context Available**:
- TASK_PROMPT.md: [Available/Created]
- Documentation (.context/data/): [X files found]
- Examples (.context/examples/): [X files found]

**Workflow Path**: [Simple/Medium/Complex workflow description]

**Expected Outputs**:
- [List of deliverables from this workflow]
```

Include this in the response to keep user informed of the process.
</decision_tracking>

<error_handling>
## Error Handling and Edge Cases

### Missing Context
- If TASK_PROMPT.md missing and no arguments: Request user input
- If complexity suggests need for docs but .context/data/ empty: Warn user
- If external APIs mentioned but no documentation: Suggest documentation needed

### Workflow Failures
- If learner command fails: Fall back to designer workflow
- If designer command fails: Fall back to builder with enhanced requirements
- Document any workflow modifications made

### Directory Issues
- Ensure permissions for directory creation
- Handle cases where .context/ cannot be created
- Provide alternative approaches if file system access limited
</error_handling>

<output_format>
## Response Structure

```markdown
# üöÄ Unified Development Workflow Started

## Input Analysis
**Mode**: [Direct Command / Document Mode]
**Enhanced Requirements**: [Summary of requirements]

## Task Complexity Assessment  
**Complexity Level**: [Simple/Medium/Complex]
**Reasoning**: [Why this complexity level was chosen]

## Context Materials Found
- TASK_PROMPT.md: ‚úÖ/‚ùå
- Documentation files: [X files in .context/data/]
- Example code: [X files in .context/examples/]

## Workflow Execution Plan
**Path**: [Workflow description]
**Commands**: [List of commands that will be executed]

## Next Steps
[Executing first command in the workflow...]
```

Then immediately execute the determined workflow commands.
</output_format>

<examples>
## Example Usage Scenarios

### Scenario 1: Simple Direct Command
```bash
/user:create "Build a React todo list component"
```
**Result**: 
- Creates enhanced TASK_PROMPT.md
- Determines: Simple task ‚Üí Direct builder
- Executes: /user:build immediately

### Scenario 2: Medium Complexity
```bash  
/user:create "Create an e-commerce platform with user auth, product catalog, and checkout"
```
**Result**:
- Creates enhanced TASK_PROMPT.md  
- Determines: Medium task ‚Üí designer + builder
- Executes: /user:design then /user:build

### Scenario 3: Complex with Documentation
```bash
/user:create "Build WeChat mini-program mall system"
# (with API docs in .context/data/ and examples in .context/examples/)
```
**Result**:
- Creates enhanced TASK_PROMPT.md
- Determines: Complex task ‚Üí learner + designer + builder  
- Executes: /user:learn, then /user:design, then /user:build

### Scenario 4: Document Mode
```bash
/user:create
# (with pre-existing detailed TASK_PROMPT.md)
```
**Result**:
- Reads existing TASK_PROMPT.md
- Analyzes complexity based on content
- Executes appropriate workflow
</examples>

<quality_assurance>
## Quality Checks

Before executing workflow:
- [ ] Requirements are clearly defined
- [ ] Complexity assessment is appropriate
- [ ] Required directories exist
- [ ] Context materials are accessible
- [ ] Workflow path is optimal for the task

During workflow execution:
- [ ] Each command completes successfully
- [ ] Generated outputs are properly formatted
- [ ] Context is properly passed between phases
- [ ] User is kept informed of progress

After workflow completion:
- [ ] All deliverables are generated
- [ ] Code quality meets standards
- [ ] Documentation is complete
- [ ] Project structure is clean and organized
</quality_assurance>